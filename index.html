<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interplanetary Golf</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        #debugInfo {
            display: none;
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            max-height: 80%;
            overflow-y: auto;
        }
        #settingsPanel, #startScreen, #goalScreen, #gameOverScreen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            color: white;
            border-radius: 10px;
            text-align: center;
        }
        #toggleSettings, #toggleZoom {
            position: absolute;
            bottom: 10px;
            padding: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #toggleSettings { right: 10px; }
        #toggleZoom { left: 10px; }
        button {
            margin: 5px;
            padding: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        #parameterSliders {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            color: white;
        }
        #shotDistance {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 20px;
            display: none;
        }
        #goalIndicator {
            position: absolute;
            color: #FFD700;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="debugInfo"></div>
    <button id="toggleSettings">Settings</button>
    <button id="toggleZoom">Show Course</button>
    <div id="settingsPanel">
        <h2>Settings</h2>
        <button id="shuffleLevel">Shuffle Level</button>
        <button id="saveLevel">Save Level</button>
        <button id="loadLevel">Load Level</button>
        <button id="exportLevels">Export Levels</button>
        <button id="toggleDebug">Toggle Debug Info</button>
        <button id="settingsMainMenu">Main Menu</button>
        <button id="closeSettings">Close</button>
    </div>
    <div id="parameterSliders">
        <div>
            <label for="gravitySlider">Gravity: <span id="gravityValue"></span></label>
            <input type="range" id="gravitySlider" min="0.001" max="0.1" step="0.001" value="0.004">
        </div>
        <div>
            <label for="shotPowerSlider">Shot Power: <span id="shotPowerValue"></span></label>
            <input type="range" id="shotPowerSlider" min="0.05" max="0.5" step="0.01" value="0.18">
        </div>
        <div>
            <label for="ballSizeSlider">Ball Size: <span id="ballSizeValue"></span></label>
            <input type="range" id="ballSizeSlider" min="2" max="10" step="0.5" value="8">
        </div>
        <div>
            <label for="trailLengthSlider">Trail Length: <span id="trailLengthValue"></span></label>
            <input type="range" id="trailLengthSlider" min="1" max="1000" step="1" value="1000">
        </div>
    </div>
    <div id="startScreen">
        <h1>Interplanetary Golf</h1>
        <button id="startGame">Start Game</button>
        <button id="showHighScores">High Scores</button>
    </div>
    <div id="goalScreen">
        <h2 id="goalMessage">Stellar Shot!</h2>
        <p id="shotCount"></p>
        <p id="parInfo"></p>
        <p id="totalDistanceGoal"></p>
        <button id="nextLevel">Next Hole</button>
        <button id="saveLevelGoal">Save Level</button>
        <button id="mainMenu">Main Menu</button>
    </div>
    <div id="gameOverScreen">
        <h2>Course Complete!</h2>
        <p id="finalShots"></p>
        <p id="coursePar"></p>
        <p id="finalScore"></p>
        <p id="totalDistance"></p>
        <button id="restartGame">Play Again</button>
        <button id="gameOverMainMenu">Main Menu</button>
    </div>
    <div id="shotDistance"></div>
    <div id="goalIndicator"></div>
<script>
// JavaScript code will start here in the next part
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const debugInfo = document.getElementById('debugInfo');

let GRAVITY = 0.004;
let SHOT_POWER = 0.18;
let TRAIL_LENGTH = 1000;
let PLAY_AREA_WIDTH = 2000;
let PLAY_AREA_HEIGHT = 1500;
let currentHole = 0;
const TOTAL_HOLES = 9;
let totalScore = 0;
let isZoomedOut = false;
let totalCoursePar = 0;
let totalCourseDistance = 0;
const PULLBACK_MULTIPLIER = 2;

const PLANET_COLORS = ['#118AB2', '#EF476F', '#FFD166', '#06D6A0', '#073B4C'];

function log(message) {
    console.log(message);
    debugInfo.innerHTML += message + '<br>';
    debugInfo.scrollTop = debugInfo.scrollHeight;
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let gameState = {
    ball: {x: 0, y: 0, vx: 0, vy: 0, r: 8, moving: false},
    planets: [],
    goal: {p: 0, aA: Math.PI/6, aW: Math.PI/3, aH: 20},
    isAiming: false,
    aimAngle: 0,
    aimPower: 0,
    goalReached: false,
    trail: [],
    lastShotDistance: 0,
    shotStartX: 0,
    shotStartY: 0,
    totalShotDistance: 0,
    holeTotalDistance: 0
};
let shotCount = 0;
let par = 0;
let stars = [];
let highScores = [];
let fireworks = [];

log('Initial setup complete');

function calculateGravity(x, y, vx, vy, planets) {
    let fx = 0, fy = 0;
    planets.forEach(pl => {
        const dx = pl.x - x, dy = pl.y - y, d2 = dx*dx + dy*dy;
        if (d2 > 1e-4) {
            const d = Math.sqrt(d2), f = (pl.m / d2) * GRAVITY;
            fx += f * dx / d;
            fy += f * dy / d;
        }
    });
    return {vx: vx + fx, vy: vy + fy};
}

function checkCollision(ball, planet) {
    return Math.hypot(ball.x - planet.x, ball.y - planet.y) < ball.r + planet.r;
}

function resolveCollision(ball, planet) {
    const dx = ball.x - planet.x, dy = ball.y - planet.y;
    const d = Math.hypot(dx, dy);
    const nx = dx / d, ny = dy / d;
    const o = (ball.r + planet.r) - d;
    ball.x += nx * o * 1.01;
    ball.y += ny * o * 1.01;
    const dp = ball.vx * nx + ball.vy * ny;
    ball.vx = (ball.vx - 2 * dp * nx) * 0.8;
    ball.vy = (ball.vy - 2 * dp * ny) * 0.8;
    
    if (Math.hypot(ball.vx, ball.vy) < 0.5) {
        ball.vx *= 0.5;
        ball.vy *= 0.5;
        if (Math.hypot(ball.vx, ball.vy) < 0.1) {
            ball.vx = ball.vy = 0;
            ball.moving = false;
        }
    }
}

function checkGoal(ball, planet, aA, aW, aH) {
    const dx = ball.x - planet.x, dy = ball.y - planet.y;
    const d = Math.hypot(dx, dy);
    const a = Math.atan2(dy, dx);
    const nA = (a + 2*Math.PI) % (2*Math.PI);
    const sA = (aA - aW/2 + 2*Math.PI) % (2*Math.PI);
    const eA = (aA + aW/2 + 2*Math.PI) % (2*Math.PI);
    return d <= planet.r + aH &&
           ((nA >= sA && nA <= eA) || (eA < sA && (nA >= sA || nA <= eA)));
}

function predictTrajectory(sX, sY, vx, vy, steps) {
    let x = sX, y = sY;
    const t = [];
    for (let i = 0; i < steps; i++) {
        t.push({x, y});
        const {vx: nVx, vy: nVy} = calculateGravity(x, y, vx, vy, gameState.planets);
        x += nVx * 0.5;
        y += nVy * 0.5;
        vx = nVx;
        vy = nVy;
        if (gameState.planets.some(p => checkCollision({x, y, r: gameState.ball.r}, p))) break;
    }
    return t;
}

function shadeColor(color, percent) {
    const num = parseInt(color.replace("#",""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
}

function generateLevel() {
    log('Generating new level');
    const planetCount = Math.floor(Math.random() * 3) + 3; // 3 to 5 planets
    const planets = [];

    const margin = Math.min(PLAY_AREA_WIDTH, PLAY_AREA_HEIGHT) * 0.15; // 15% margin

    for (let i = 0; i < planetCount; i++) {
        let x, y, r;
        do {
            x = Math.random() * (PLAY_AREA_WIDTH - 2 * margin) + margin;
            y = Math.random() * (PLAY_AREA_HEIGHT - 2 * margin) + margin;
            r = Math.random() * 30 + 30; // radius between 30 and 60
        } while (planets.some(p => Math.hypot(p.x - x, p.y - y) < p.r + r + 100));

        const colorIndex = Math.floor(Math.random() * PLANET_COLORS.length);
        const mainColor = PLANET_COLORS[colorIndex];
        const secondaryColor = shadeColor(mainColor, -30);
        planets.push({
            x, y, r,
            m: r * r * 100,
            mainColor: mainColor,
            secondaryColor: secondaryColor,
            atmosphere: true
        });
    }

    const startPlanet = planets[0];
    const goalPlanet = planets[planets.length - 1];
    const dx = goalPlanet.x - startPlanet.x;
    const dy = goalPlanet.y - startPlanet.y;
    const distance = Math.hypot(dx, dy);
    
    par = Math.ceil(distance / 400) + planets.length - 2;
    totalCoursePar += par;

    log(`Level generated with ${planetCount} planets. Par: ${par}`);

    return {
        planets,
        goal: {p: planets.length - 1, aA: Math.atan2(dy, dx), aW: Math.PI/3, aH: 20},
        par
    };
}

function createFireworks() {
    for (let i = 0; i < 5; i++) {
        fireworks.push({
            x: Math.random() * canvas.width,
            y: canvas.height,
            vx: Math.random() * 4 - 2,
            vy: -Math.random() * 4 - 6,
            color: `hsl(${Math.random() * 360}, 100%, 50%)`,
            particles: []
        });
    }
}

function calculateShotDistance(startX, startY, endX, endY) {
    return Math.hypot(endX - startX, endY - startY);
}

function updateShotDistanceDisplay() {
    const shotDistanceElement = document.getElementById('shotDistance');
    if (gameState.lastShotDistance > 0) {
        shotDistanceElement.textContent = `Last shot: ${gameState.lastShotDistance.toFixed(1)} IAU`;
        shotDistanceElement.style.display = 'block';
    }
}

log('Core game mechanics and utility functions defined');
function update() {
    const {ball, planets, goal} = gameState;
    if (ball.moving) {
        const prevX = ball.x;
        const prevY = ball.y;
        
        gameState.trail.push({x: ball.x, y: ball.y});
        if (gameState.trail.length > TRAIL_LENGTH) gameState.trail.shift();

        const {vx, vy} = calculateGravity(ball.x, ball.y, ball.vx, ball.vy, planets);
        ball.x += vx * 0.5;
        ball.y += vy * 0.5;
        ball.vx = vx;
        ball.vy = vy;

        const distanceMoved = Math.hypot(ball.x - prevX, ball.y - prevY);
        gameState.totalShotDistance += distanceMoved;
        gameState.holeTotalDistance += distanceMoved;

        planets.forEach(pl => {
            if (checkCollision(ball, pl)) resolveCollision(ball, pl);
        });

        if (ball.x < 0 || ball.x > PLAY_AREA_WIDTH || ball.y < 0 || ball.y > PLAY_AREA_HEIGHT) {
            resetBallToStartPlanet();
            log('Ball out of bounds. Resetting position.');
        }

        if (checkGoal(ball, planets[goal.p], goal.aA, goal.aW, goal.aH)) {
            gameState.goalReached = true;
            ball.moving = false;
            gameState.lastShotDistance = gameState.totalShotDistance;
            totalCourseDistance += gameState.holeTotalDistance;
            showGoalScreen();
            if (shotCount === 1) {
                createFireworks();
            }
            log('Goal reached!');
        }

        if (!ball.moving) {
            gameState.lastShotDistance = gameState.totalShotDistance;
            updateShotDistanceDisplay();
        }
    }

    // Update fireworks
    fireworks.forEach((fw, index) => {
        fw.x += fw.vx;
        fw.y += fw.vy;
        fw.vy += 0.1;

        if (fw.vy >= 0 && fw.particles.length === 0) {
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                fw.particles.push({
                    x: fw.x,
                    y: fw.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    alpha: 1
                });
            }
        }

        fw.particles.forEach((p, pIndex) => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05;
            p.alpha -= 0.01;

            if (p.alpha <= 0) {
                fw.particles.splice(pIndex, 1);
            }
        });

        if (fw.particles.length === 0 && fw.y > canvas.height) {
            fireworks.splice(index, 1);
        }
    });
}

function render() {
    ctx.fillStyle = '#05071A';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const startPlanet = gameState.planets[0];
    const goalPlanet = gameState.planets[gameState.goal.p];
    const centerX = (startPlanet.x + goalPlanet.x) / 2;
    const centerY = (startPlanet.y + goalPlanet.y) / 2;

    const scaleFactor = isZoomedOut ? Math.min(canvas.width / PLAY_AREA_WIDTH, canvas.height / PLAY_AREA_HEIGHT) : 1;
    const oX = isZoomedOut ? canvas.width/2 - centerX * scaleFactor : canvas.width/2 - gameState.ball.x * scaleFactor;
    const oY = isZoomedOut ? canvas.height/2 - centerY * scaleFactor : canvas.height/2 - gameState.ball.y * scaleFactor;

    // Draw stars
    ctx.fillStyle = 'white';
    stars.forEach(s => {
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.s, 0, 2*Math.PI);
        ctx.fill();
    });

    // Draw play area boundary
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.strokeRect(oX, oY, PLAY_AREA_WIDTH * scaleFactor, PLAY_AREA_HEIGHT * scaleFactor);
    ctx.setLineDash([]);

    // Draw planets
    gameState.planets.forEach((p, i) => {
        ctx.save();
        ctx.translate(p.x * scaleFactor + oX, p.y * scaleFactor + oY);

        // Draw atmosphere
        if (p.atmosphere) {
            const atmosphereGradient = ctx.createRadialGradient(0, 0, p.r * scaleFactor, 0, 0, p.r * 1.2 * scaleFactor);
            atmosphereGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
            atmosphereGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = atmosphereGradient;
            ctx.beginPath();
            ctx.arc(0, 0, p.r * 1.2 * scaleFactor, 0, 2*Math.PI);
            ctx.fill();
        }

        // Draw main planet body
        const planetGradient = ctx.createRadialGradient(-p.r * 0.3 * scaleFactor, -p.r * 0.3 * scaleFactor, 0, 0, 0, p.r * scaleFactor);
        planetGradient.addColorStop(0, p.mainColor);
        planetGradient.addColorStop(1, shadeColor(p.mainColor, -30));
        ctx.fillStyle = planetGradient;
        ctx.beginPath();
        ctx.arc(0, 0, p.r * scaleFactor, 0, 2*Math.PI);
        ctx.fill();

        // Draw highlight
        const highlightGradient = ctx.createRadialGradient(
            -p.r * 0.3 * scaleFactor, -p.r * 0.3 * scaleFactor, 0,
            0, 0, p.r * scaleFactor
        );
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = highlightGradient;
        ctx.beginPath();
        ctx.arc(0, 0, p.r * scaleFactor, 0, 2*Math.PI);
        ctx.fill();

        ctx.restore();

        if (i === gameState.goal.p) {
            const archRadius = (p.r + gameState.goal.aH) * scaleFactor;
            const startAngle = gameState.goal.aA - gameState.goal.aW / 2;
            const endAngle = gameState.goal.aA + gameState.goal.aW / 2;
            
            ctx.beginPath();
            ctx.arc(p.x * scaleFactor + oX, p.y * scaleFactor + oY, archRadius, startAngle, endAngle);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 5 * scaleFactor;
            ctx.stroke();

            // Draw lines connecting the arch to the planet surface
            ctx.beginPath();
            ctx.moveTo(p.x * scaleFactor + oX + p.r * scaleFactor * Math.cos(startAngle), p.y * scaleFactor + oY + p.r * scaleFactor * Math.sin(startAngle));
            ctx.lineTo(p.x * scaleFactor + oX + archRadius * Math.cos(startAngle), p.y * scaleFactor + oY + archRadius * Math.sin(startAngle));
            ctx.moveTo(p.x * scaleFactor + oX + p.r * scaleFactor * Math.cos(endAngle), p.y * scaleFactor + oY + p.r * scaleFactor * Math.sin(endAngle));
            ctx.lineTo(p.x * scaleFactor + oX + archRadius * Math.cos(endAngle), p.y * scaleFactor + oY + archRadius * Math.sin(endAngle));
            ctx.stroke();
        }
    });

    // Draw trail
    if (gameState.trail.length > 1) {
        ctx.beginPath();
        ctx.moveTo(gameState.trail[0].x * scaleFactor + oX, gameState.trail[0].y * scaleFactor + oY);
        for (let i = 1; i < gameState.trail.length; i++) {
            ctx.lineTo(gameState.trail[i].x * scaleFactor + oX, gameState.trail[i].y * scaleFactor + oY);
        }
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2 * scaleFactor;
        ctx.stroke();
    }

    // Draw ball
    const ballX = gameState.ball.x * scaleFactor + oX;
    const ballY = gameState.ball.y * scaleFactor + oY;
    ctx.beginPath();
    ctx.arc(ballX, ballY, gameState.ball.r * scaleFactor, 0, 2*Math.PI);
    ctx.fillStyle = 'white';
    ctx.fill();

    // Draw aim line and trajectory
    if (gameState.isAiming && !gameState.ball.moving) {
        ctx.beginPath();
        ctx.moveTo(ballX, ballY);
        const visualPullback = gameState.aimPower * PULLBACK_MULTIPLIER;
        const eX = ballX - Math.cos(gameState.aimAngle) * visualPullback * 2.67 * scaleFactor;
        const eY = ballY - Math.sin(gameState.aimAngle) * visualPullback * 2.67 * scaleFactor;
        ctx.lineTo(eX, eY);
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2 * scaleFactor;
        ctx.stroke();

        const vx = Math.cos(gameState.aimAngle) * gameState.aimPower * SHOT_POWER;
        const vy = Math.sin(gameState.aimAngle) * gameState.aimPower * SHOT_POWER;
        const t = predictTrajectory(gameState.ball.x, gameState.ball.y, vx, vy, 200);
        ctx.beginPath();
        ctx.setLineDash([5*scaleFactor, 5*scaleFactor]);
        ctx.moveTo(t[0].x * scaleFactor + oX, t[0].y * scaleFactor + oY);
        t.forEach(p => ctx.lineTo(p.x * scaleFactor + oX, p.y * scaleFactor + oY));
        ctx.strokeStyle = 'rgba(255,255,0,0.5)';
        ctx.lineWidth = 2 * scaleFactor;
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Draw shot counter, par, and hole counter
    ctx.font = '20px Arial';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'left';
    ctx.fillText(`Shots: ${shotCount}`, 10, 30);
    ctx.fillText(`Par: ${par}`, 10, 60);
    ctx.fillText(`Hole: ${currentHole + 1}/${TOTAL_HOLES}`, 10, 90);

    
// Draw goal indicator
const goalPlanetScreenX = goalPlanet.x * scaleFactor + oX;
const goalPlanetScreenY = goalPlanet.y * scaleFactor + oY;
const goalAreaRadius = (goalPlanet.r + gameState.goal.aH) * scaleFactor;

const edgeMargin = Math.min(canvas.width, canvas.height) * 0.15; // 15% margin
const isGoalOffscreen = 
    goalPlanetScreenX < edgeMargin || goalPlanetScreenX > canvas.width - edgeMargin ||
    goalPlanetScreenY < edgeMargin || goalPlanetScreenY > canvas.height - edgeMargin;

if (isGoalOffscreen) {
    const dx = goalPlanet.x - gameState.ball.x;
    const dy = goalPlanet.y - gameState.ball.y;
    const distanceToGoal = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx);

    // Calculate the position of the indicator
    let indicatorX = canvas.width / 2 + Math.cos(angle) * (canvas.width / 2 - edgeMargin);
    let indicatorY = canvas.height / 2 + Math.sin(angle) * (canvas.height / 2 - edgeMargin);

    // Clamp the indicator position to stay within the allowed area
    indicatorX = Math.max(edgeMargin, Math.min(canvas.width - edgeMargin, indicatorX));
    indicatorY = Math.max(edgeMargin, Math.min(canvas.height - edgeMargin, indicatorY));

    // Recalculate angle based on clamped position
    const clampedAngle = Math.atan2(goalPlanetScreenY - indicatorY, goalPlanetScreenX - indicatorX);

    // Draw arrow
    ctx.save();
    ctx.translate(indicatorX, indicatorY);
    ctx.rotate(clampedAngle);
    ctx.beginPath();
    ctx.moveTo(-10, -5);
    ctx.lineTo(0, 0);
    ctx.lineTo(-10, 5);
    ctx.strokeStyle = '#FFD700';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // Draw distance text
    ctx.font = '14px Arial';
    ctx.fillStyle = '#FFD700';
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.round(distanceToGoal)} IAU`, indicatorX, indicatorY - 20);
}

    // Draw fireworks
    fireworks.forEach(fw => {
        ctx.beginPath();
        ctx.arc(fw.x, fw.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = fw.color;
        ctx.fill();

        fw.particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 1, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${parseInt(fw.color.slice(1, 3), 16)}, ${parseInt(fw.color.slice(3, 5), 16)}, ${parseInt(fw.color.slice(5, 7), 16)}, ${p.alpha})`;
            ctx.fill();
        });
    });
}

function gameLoop() {
    update();
    render();
    requestAnimationFrame(gameLoop);
}

log('Render function and game loop defined');
function handleStart(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX || e.touches[0].clientX) - rect.left;
    const y = (e.clientY || e.touches[0].clientY) - rect.top;
    
    if (isZoomedOut) {
        isZoomedOut = false;
        toggleZoom.textContent = 'Show Course';
        return;
    }

    if (!gameState.ball.moving && !gameState.goalReached) {
        gameState.isAiming = true;
        gameState.aimAngle = Math.atan2(canvas.height/2-y, canvas.width/2-x);
        gameState.aimPower = 0;
        log('Aiming started');
    }
}

function handleMove(e) {
    if (gameState.isAiming && !gameState.ball.moving) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        gameState.aimAngle = Math.atan2(canvas.height/2-y, canvas.width/2-x);
        
        const distance = Math.hypot(x-canvas.width/2, y-canvas.height/2);
        gameState.aimPower = Math.min(66.67, distance / PULLBACK_MULTIPLIER);
    }
}

function handleEnd() {
    if (gameState.isAiming && !gameState.ball.moving) {
        gameState.isAiming = false;
        if (gameState.aimPower > 10) {
            gameState.ball.vx = Math.cos(gameState.aimAngle) * gameState.aimPower * SHOT_POWER;
            gameState.ball.vy = Math.sin(gameState.aimAngle) * gameState.aimPower * SHOT_POWER;
            gameState.ball.moving = true;
            gameState.trail = [];
            shotCount++;
            gameState.shotStartX = gameState.ball.x;
            gameState.shotStartY = gameState.ball.y;
            gameState.lastShotDistance = 0;
            gameState.totalShotDistance = 0;
            updateShotDistanceDisplay();
            log(`Shot taken. Total shots: ${shotCount}`);
        } else {
            log('Shot cancelled (in deadzone)');
        }
    }
}

function startNewGame() {
    currentHole = 0;
    totalScore = 0;
    totalCoursePar = 0;
    totalCourseDistance = 0;
    resetGame();
    toggleSettings.style.display = 'block';
    toggleZoom.style.display = 'block';
}

canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('touchstart', handleStart);
canvas.addEventListener('touchmove', handleMove);
canvas.addEventListener('touchend', handleEnd);

const settingsPanel = document.getElementById('settingsPanel');
const toggleSettings = document.getElementById('toggleSettings');
const gravitySlider = document.getElementById('gravitySlider');
const shotPowerSlider = document.getElementById('shotPowerSlider');
const ballSizeSlider = document.getElementById('ballSizeSlider');
const trailLengthSlider = document.getElementById('trailLengthSlider');
const gravityValue = document.getElementById('gravityValue');
const shotPowerValue = document.getElementById('shotPowerValue');
const ballSizeValue = document.getElementById('ballSizeValue');
const trailLengthValue = document.getElementById('trailLengthValue');
const shuffleLevel = document.getElementById('shuffleLevel');
const saveLevel = document.getElementById('saveLevel');
const loadLevel = document.getElementById('loadLevel');
const exportLevels = document.getElementById('exportLevels');
const toggleDebug = document.getElementById('toggleDebug');
const closeSettings = document.getElementById('closeSettings');
const startScreen = document.getElementById('startScreen');
const startGame = document.getElementById('startGame');
const showHighScores = document.getElementById('showHighScores');
const goalScreen = document.getElementById('goalScreen');
const nextLevel = document.getElementById('nextLevel');
const saveLevelGoal = document.getElementById('saveLevelGoal');
const mainMenu = document.getElementById('mainMenu');
const toggleZoom = document.getElementById('toggleZoom');
const parameterSliders = document.getElementById('parameterSliders');
const settingsMainMenu = document.getElementById('settingsMainMenu');

toggleSettings.addEventListener('click', () => {
    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
    log('Settings toggled');
});

function updateSettings() {
    GRAVITY = parseFloat(gravitySlider.value);
    SHOT_POWER = parseFloat(shotPowerSlider.value);
    gameState.ball.r = parseFloat(ballSizeSlider.value);
    TRAIL_LENGTH = parseInt(trailLengthSlider.value);
    
    gravityValue.textContent = GRAVITY.toFixed(3);
    shotPowerValue.textContent = SHOT_POWER.toFixed(2);
    ballSizeValue.textContent = gameState.ball.r.toFixed(1);
    trailLengthValue.textContent = TRAIL_LENGTH;
    log('Settings updated');
}

gravitySlider.addEventListener('input', updateSettings);
shotPowerSlider.addEventListener('input', updateSettings);
ballSizeSlider.addEventListener('input', updateSettings);
trailLengthSlider.addEventListener('input', updateSettings);
shuffleLevel.addEventListener('click', () => {
    resetGame();
    settingsPanel.style.display = 'none';
});

saveLevel.addEventListener('click', () => {
    const levelName = prompt("Enter a name for this level:");
    if (levelName) {
        const levelData = JSON.stringify({
            planets: gameState.planets,
            goal: gameState.goal,
            par: par
        });
        localStorage.setItem(`level_${levelName}`, levelData);
        log(`Level "${levelName}" saved`);
    }
});

loadLevel.addEventListener('click', () => {
    const levels = Object.keys(localStorage).filter(key => key.startsWith('level_'));
    if (levels.length === 0) {
        alert("No saved levels found");
        return;
    }
    const levelName = prompt("Enter the name of the level to load:\n" + levels.map(l => l.slice(6)).join(', '));
    if (levelName) {
        const levelData = localStorage.getItem(`level_${levelName}`);
        if (levelData) {
            const level = JSON.parse(levelData);
            gameState.planets = level.planets;
            gameState.goal = level.goal;
            par = level.par;
            resetBallToStartPlanet();
            log(`Level "${levelName}" loaded`);
        } else {
            alert("Level not found");
        }
    }
});

exportLevels.addEventListener('click', () => {
    const levels = Object.keys(localStorage).filter(key => key.startsWith('level_'));
    if (levels.length === 0) {
        alert("No saved levels found");
        return;
    }
    let exportData = "";
    levels.forEach(key => {
        exportData += key + "\n" + localStorage.getItem(key) + "\n\n";
    });
    const blob = new Blob([exportData], {type: 'text/plain'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'space_golf_levels.txt';
    a.click();
});

toggleDebug.addEventListener('click', () => {
    debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
    parameterSliders.style.display = parameterSliders.style.display === 'none' ? 'block' : 'none';
    log('Debug info and parameter sliders toggled');
});

closeSettings.addEventListener('click', () => {
    settingsPanel.style.display = 'none';
});

startGame.addEventListener('click', () => {
    startScreen.style.display = 'none';
    startNewGame();
    if (!gameLoopStarted) {
        gameLoop();
        gameLoopStarted = true;
    }
});

showHighScores.addEventListener('click', () => {
    const scoreDisplay = highScores.map((score, index) => 
        `${index + 1}. ${score.date}: Total Shots: ${score.totalShots}, Par: ${score.coursePar}, ${score.relativeToPar > 0 ? '+' : ''}${score.relativeToPar}`
    ).join('\n');
    alert(scoreDisplay || 'No high scores yet!');
});

log('Event handlers and core game logic defined');
nextLevel.addEventListener('click', () => {
    goalScreen.style.display = 'none';
    totalScore += shotCount;
    if (currentHole < TOTAL_HOLES - 1) {
        currentHole++;
        resetGame();
    } else {
        showGameOverScreen();
    }
});

saveLevelGoal.addEventListener('click', () => {
    const levelName = prompt("Enter a name for this level:");
    if (levelName) {
        const levelData = JSON.stringify({
            planets: gameState.planets,
            goal: gameState.goal,
            par: par
        });
        localStorage.setItem(`level_${levelName}`, levelData);
        log(`Level "${levelName}" saved`);
    }
});

mainMenu.addEventListener('click', () => {
    goalScreen.style.display = 'none';
    startScreen.style.display = 'block';
    toggleSettings.style.display = 'none';
    toggleZoom.style.display = 'none';
});

settingsMainMenu.addEventListener('click', () => {
    settingsPanel.style.display = 'none';
    startScreen.style.display = 'block';
    toggleSettings.style.display = 'none';
    toggleZoom.style.display = 'none';
});

toggleZoom.addEventListener('click', () => {
    isZoomedOut = !isZoomedOut;
    toggleZoom.textContent = isZoomedOut ? 'Focus Ball' : 'Show Course';
});

function showGameOverScreen() {
    document.getElementById('finalShots').textContent = `Total Shots: ${totalScore}`;
    document.getElementById('coursePar').textContent = `Course Par: ${totalCoursePar}`;
    document.getElementById('finalScore').textContent = `Final Score: ${totalScore - totalCoursePar > 0 ? '+' : ''}${totalScore - totalCoursePar}`;
    document.getElementById('totalDistance').textContent = `Total Distance: ${totalCourseDistance.toFixed(1)} IAU`;
    document.getElementById('gameOverScreen').style.display = 'block';
    toggleSettings.style.display = 'none';
    toggleZoom.style.display = 'none';
    saveHighScore();
}

document.getElementById('restartGame').addEventListener('click', () => {
    document.getElementById('gameOverScreen').style.display = 'none';
    startNewGame();
});

document.getElementById('gameOverMainMenu').addEventListener('click', () => {
    document.getElementById('gameOverScreen').style.display = 'none';
    startScreen.style.display = 'block';
    toggleSettings.style.display = 'none';
    toggleZoom.style.display = 'none';
});

function initStars() {
    stars = Array.from({length: 1000}, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        s: Math.random() * 0.5 + 0.1,
    }));
}

window.addEventListener('resize', () => {
    resizeCanvas();
    initStars();
});

function saveHighScore() {
    if (currentHole === TOTAL_HOLES - 1) {
        const currentDate = new Date().toLocaleString();
        const score = { 
            date: currentDate, 
            totalShots: totalScore, 
            coursePar: totalCoursePar,
            relativeToPar: totalScore - totalCoursePar
        };
        highScores.push(score);
        highScores.sort((a, b) => a.totalShots - b.totalShots);
        highScores = highScores.slice(0, 10);
        localStorage.setItem('highScores', JSON.stringify(highScores));
    }
}

function loadHighScores() {
    const savedScores = localStorage.getItem('highScores');
    if (savedScores) {
        highScores = JSON.parse(savedScores);
        highScores = highScores.filter(score => score.date && score.totalShots !== undefined && score.coursePar !== undefined);
    }
}

function resetBallToStartPlanet() {
    const startPlanet = gameState.planets[0];
    const spawnDistance = startPlanet.r + gameState.ball.r + 5;
    const spawnAngle = Math.random() * 2 * Math.PI;
    gameState.ball.x = startPlanet.x + Math.cos(spawnAngle) * spawnDistance;
    gameState.ball.y = startPlanet.y + Math.sin(spawnAngle) * spawnDistance;
    gameState.ball.vx = 0;
    gameState.ball.vy = 0;
    gameState.ball.moving = false;
    gameState.lastShotDistance = gameState.totalShotDistance;
    gameState.totalShotDistance = 0;
    gameState.shotStartX = gameState.ball.x;
    gameState.shotStartY = gameState.ball.y;
    updateShotDistanceDisplay();
}

function resetGame() {
    const levelData = generateLevel();
    gameState.planets = levelData.planets;
    gameState.goal = levelData.goal;
    par = levelData.par;
    gameState.ball = {x: 0, y: 0, vx: 0, vy: 0, r: parseFloat(ballSizeSlider.value), moving: false};
    gameState.isAiming = false;
    gameState.aimAngle = 0;
    gameState.aimPower = 0;
    gameState.goalReached = false;
    gameState.trail = [];
    gameState.lastShotDistance = 0;
    gameState.totalShotDistance = 0;
    gameState.holeTotalDistance = 0;
    gameState.shotStartX = 0;
    gameState.shotStartY = 0;
    shotCount = 0;
    resetBallToStartPlanet();
    updateShotDistanceDisplay();
    log('Game reset');
}

let gameLoopStarted = false;

function initGame() {
    updateSettings();
    initStars();
    loadHighScores();
    startScreen.style.display = 'block';
    toggleSettings.style.display = 'none';
    toggleZoom.style.display = 'none';
    log('Game initialized and ready to start');
}

window.addEventListener('load', initGame);

document.body.addEventListener('touchstart', function(e) {
    if (e.target == canvas) {
        e.preventDefault();
    }
}, { passive: false });

document.body.addEventListener('touchend', function(e) {
    if (e.target == canvas) {
        e.preventDefault();
    }
}, { passive: false });

document.body.addEventListener('touchmove', function(e) {
    if (e.target == canvas) {
        e.preventDefault();
    }
}, { passive: false });

canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});

function showGoalScreen() {
    document.getElementById('shotCount').textContent = `Shots: ${shotCount}`;
    document.getElementById('parInfo').textContent = `Par: ${par}`;
    document.getElementById('totalDistanceGoal').textContent = `Total Distance: ${gameState.holeTotalDistance.toFixed(1)} IAU`;
    document.getElementById('nextLevel').textContent = currentHole === TOTAL_HOLES - 1 ? 'Finish Course' : `Next Hole (${currentHole + 2}/${TOTAL_HOLES})`;
    
    let message;
    if (shotCount === 1) {
        message = "Cosmic Hole-in-One!";
        createFireworks(); // Create fireworks for hole-in-one
    } else if (shotCount < par - 1) {
        message = "Interstellar Eagle!";
    } else if (shotCount === par - 1) {
        message = "Galactic Birdie!";
    } else if (shotCount === par) {
        message = "Nebula Par!";
    } else if (shotCount === par + 1) {
        message = "Black Hole Bogey!";
    } else {
        message = "Supernova Double Bogey+!";
    }
    
    document.getElementById('goalMessage').textContent = message;
    document.getElementById('goalScreen').style.display = 'block';
}

log('Game initialization and event listeners set up');
// Prevent default touch behavior to avoid unwanted scrolling
document.body.addEventListener('touchstart', function(e) {
    if (e.target == canvas) {
        e.preventDefault();
    }
}, { passive: false });

document.body.addEventListener('touchend', function(e) {
    if (e.target == canvas) {
        e.preventDefault();
    }
}, { passive: false });

document.body.addEventListener('touchmove', function(e) {
    if (e.target == canvas) {
        e.preventDefault();
    }
}, { passive: false });

// Prevent context menu on right-click
canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});

// Function to update the shot distance display
function updateShotDistanceDisplay() {
    const shotDistanceElement = document.getElementById('shotDistance');
    if (gameState.lastShotDistance > 0) {
        shotDistanceElement.textContent = `Last shot: ${gameState.lastShotDistance.toFixed(1)} IAU`;
        shotDistanceElement.style.display = 'block';
    } else {
        shotDistanceElement.style.display = 'none';
    }
}

// Function to create fireworks
function createFireworks() {
    for (let i = 0; i < 5; i++) {
        fireworks.push({
            x: Math.random() * canvas.width,
            y: canvas.height,
            vx: Math.random() * 4 - 2,
            vy: -Math.random() * 4 - 6,
            color: `hsl(${Math.random() * 360}, 100%, 50%)`,
            particles: []
        });
    }
}

// Function to show the goal screen
function showGoalScreen() {
    document.getElementById('shotCount').textContent = `Shots: ${shotCount}`;
    document.getElementById('parInfo').textContent = `Par: ${par}`;
    document.getElementById('totalDistanceGoal').textContent = `Total Distance: ${gameState.holeTotalDistance.toFixed(1)} IAU`;
    document.getElementById('nextLevel').textContent = currentHole === TOTAL_HOLES - 1 ? 'Finish Course' : `Next Hole (${currentHole + 2}/${TOTAL_HOLES})`;
    
    let message;
    if (shotCount === 1) {
        message = "Cosmic Hole-in-One!";
        createFireworks(); // Create fireworks for hole-in-one
    } else if (shotCount < par - 1) {
        message = "Interstellar Eagle!";
    } else if (shotCount === par - 1) {
        message = "Galactic Birdie!";
    } else if (shotCount === par) {
        message = "Nebula Par!";
    } else if (shotCount === par + 1) {
        message = "Black Hole Bogey!";
    } else {
        message = "Supernova Double Bogey+!";
    }
    
    document.getElementById('goalMessage').textContent = message;
    document.getElementById('goalScreen').style.display = 'block';
}

// Function to calculate shot distance
function calculateShotDistance(startX, startY, endX, endY) {
    return Math.hypot(endX - startX, endY - startY);
}

// Main game loop
function gameLoop() {
    update();
    render();
    requestAnimationFrame(gameLoop);
}

// Initialize the game
function initGame() {
    updateSettings();
    initStars();
    loadHighScores();
    startScreen.style.display = 'block';
    toggleSettings.style.display = 'none';
    toggleZoom.style.display = 'none';
    log('Game initialized and ready to start');
}

// Event listener for loading the game
window.addEventListener('load', initGame);

// Start the game loop when the start game button is clicked
startGame.addEventListener('click', () => {
    startScreen.style.display = 'none';
    startNewGame();
    if (!gameLoopStarted) {
        gameLoop();
        gameLoopStarted = true;
    }
});

log('Game fully set up and ready to play!');
</script>
</body>
</html>
